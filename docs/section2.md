# Rust の基本文法

## 1. コアライブラリと標準ライブラリ

### コアライブラリ

- ライブラリの中で最も根幹にあたるもの
- 他のライブラリ、プラットフォームに依存しない最小限の機能を備えたもの
- 例：数値型、文字列型の `str`、タプル、配列などの基本的な型

### 標準ライブラリ

- 「std」で用いられている標準ライブラリは便利な機能が実装されている
- 例：`Vec`、`Option`、`Result` などの型

## 2. 型について

### 数値型

アルファベット 1 文字とビットの数値で表現

#### 符号あり整数型 (Signed Integer)

| 型   | ビット数   | 範囲                                                                                                        |
| ---- | ---------- | ----------------------------------------------------------------------------------------------------------- |
| i8   | 8 ビット   | -128 ～ 127                                                                                                 |
| i16  | 16 ビット  | -32,768 ～ 32,767                                                                                           |
| i32  | 32 ビット  | -2,147,483,648 ～ 2,147,483,647                                                                             |
| i64  | 64 ビット  | -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807                                                     |
| i128 | 128 ビット | -170,141,183,460,469,231,731,687,303,715,884,105,728 ～ 170,141,183,460,469,231,731,687,303,715,884,105,727 |

#### 符号なし整数型 (Unsigned Integer)

| 型   | ビット数   | 範囲                                                     |
| ---- | ---------- | -------------------------------------------------------- |
| u8   | 8 ビット   | 0 ～ 255                                                 |
| u16  | 16 ビット  | 0 ～ 65,535                                              |
| u32  | 32 ビット  | 0 ～ 4,294,967,295                                       |
| u64  | 64 ビット  | 0 ～ 18,446,744,073,709,551,615                          |
| u128 | 128 ビット | 0 ～ 340,282,366,920,938,463,463,374,607,431,768,211,455 |

#### 浮動小数点型 (Floating Point)

Rust の浮動小数点型は IEEE-754 規格に基づいています。

| 型  | ビット数  | 範囲                                                         |
| --- | --------- | ------------------------------------------------------------ |
| f32 | 32 ビット | -3.4028235 × 10^38 ～ +3.4028235 × 10^38                     |
| f64 | 64 ビット | -1.7976931348623157 × 10^308 ～ +1.7976931348623157 × 10^308 |

#### 特殊な数値型

- `isize`、`usize` 型はアーキテクチャのメモリ空間に依存してサイズが変わる
- 32 ビット環境なら 32 ビットに
- サイズを適切に決めることでメモリ効率の最適化が可能

### 文字列型

#### 文字列型の種類

- コアライブラリ: `str`（プリミティブ型）
- 標準ライブラリ: `String`（標準ライブラリ型）
- 相互に変換可能

#### str と String の比較

| 特徴       | str                        | String                                       |
| ---------- | -------------------------- | -------------------------------------------- |
| 型の種類   | プリミティブ型（基本型）   | 標準ライブラリが提供する型                   |
| 所有権     | 所有権を持たない（参照型） | 所有権を持つ                                 |
| メモリ配置 | スタックまたは静的領域     | ヒープ上で動的に確保                         |
| サイズ     | 固定長                     | 可変長                                       |
| 変更可能性 | 変更不可                   | 変更可能                                     |
| 例         | `let s: &str = "hello";`   | `let mut s: String = String::from("hello");` |

#### 使い分けの基準

##### &str を使用する場合

- 固定長で変更しない文字列が必要な場合
- 関数の引数や文字列リテラルを扱う場合
- 軽量で効率的な参照が必要な場合

```rust
fn greet(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let name = "Rust"; // &str型
    greet(name);       // &strを渡す
}
```

##### String を使用する場合

- 動的に変更可能な文字列が必要な場合
- 文字列の結合や内容の変更が必要な場合
- 大きな文字列や頻繁な操作が必要な場合

```rust
fn main() {
    let mut message = String::from("Hello");
    message.push_str(", Rust!"); // 文字列を追加
    println!("{}", message);    // "Hello, Rust!"
}
```

### タプル型

- 文字列型と数値型を収める事の出来る集合
- アクセスの仕方はドット＋数値

### ユーザ定義型

- 構造体 `struct` で定義する
- 列挙型 `enum` で定義する

## 3. 所有権システム

### 所有権（Ownership）

#### 基本ルール

1. 各値は所有者（変数）を持つ
2. 一度に 1 つの所有者のみ
3. 所有者がスコープを抜けると値は破棄される

#### 例

```rust
fn main() {
    let s = String::from("hello"); // sが所有者
    takes_ownership(s);            // sの所有権が関数に移動
    // println!("{}", s);         // エラー。sはもう所有権を持っていない
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_stringがスコープを抜けると破棄される
```

### 借用（Borrowing）

#### 参照の種類

- 不変参照（&T）: 読み取り専用
- 可変参照（&mut T）: 読み書き可能

#### 借用のルール

1. 不変参照は複数持てる
2. 可変参照は 1 つだけ
3. 不変参照と可変参照は同時に持てない

#### 例

```rust
fn main() {
    let mut s = String::from("hello");

    // 不変参照
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2); // OK

    // 可変参照
    let r3 = &mut s;
    r3.push_str(", world");
    println!("{}", r3); // OK

    // println!("{}", r1); // エラー！不変参照と可変参照は同時に持てない
}
```

### ライフタイム（Lifetime）

#### 基本概念

- 参照が有効な期間を指定
- コンパイラが参照の有効性を保証
- 主にジェネリックライフタイムパラメータとして使用

#### ライフタイム注釈の例

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

## 4. 所有権システムの利点

### メモリ安全性

- ダングリングポインタの防止
- 二重解放の防止
- メモリリークの防止

### スレッド安全性

- データ競合の防止
- デッドロックの防止
- 安全な並行処理

### パフォーマンス

- ガベージコレクション不要
- 実行時のオーバーヘッド最小化
- コンパイル時の最適化

## 5. 実践的な使用例

### 所有権の移動

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有権の移動
    // println!("{}", s1); // エラー。s1は所有権を失った
    println!("{}", s2); // OK
}
```

### 借用の活用

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("The length of '{}' is {}.", s, len);
}
```

### ライフタイムの指定

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }

    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```
